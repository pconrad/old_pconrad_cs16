<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>CS16, el03, 10W--Problem solving on arrays (Part 2)--(Practice for Final Exam)</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../../cs16.css" />
<link rel="stylesheet" type="text/css" href="../../../cs16_labs.css" />
<style type="text/css">
.doubleSizeMath {font-size: 2.0em; font-family:"Times New Roman", Times, serif;}
.singleSizeMath {font-family:"Times New Roman", Times, serif;}
td.codes {font-size:0.8em; font-family:serif}
td {text-align: center;}
.smallerFont { font-size: 0.8em;}
.bigLiteral {font-size: xx-large; font-family:"Courier New", Courier, monospace;}
.subtle {
	color: #666666;
	font-style: italic;
	font-size: 0.9em;
}
code {white-space:pre;}
table.functionGroups tr td {  padding: 1em; vertical-align:top; text-align:left;} 
table.functionGroups {width: 80%;}
.indented {padding-left: 2em;}
.bigSansSerif {font-family:Arial, Helvetica, sans-serif; font-size: 2.0em;}
pre.indentedPre { padding-left: 2em; width: auto; font-size: 0.7em;}
table.commandSummary tr td {font-size: 0.8em; padding: 0.5em;}
/* table.commandSummary  {width: 80%;} */

.style1 {font-size: x-small}
td.noBorder {border:none;}
</style>
</head>

<body>
<div id="container">
 <h1>CS16, Winter 2010</h1>
 <h1>el03: <span class="smallerFont">(&quot;extra lab three&quot;)<br>
 Problem solving on arrays (Part 2)</span></h1>
 <div class="importantDiv">
 <p>el03 is offered as a <em><strong>recommended</strong></em> activity to help you study for the final exam.<br>
 </p>
 <p> It will not be graded, and is not offered for extra credit.<span class="smallerFont"></p>
 <p>Since this is not graded:</p>
 <ul>
   <li>	You may do this alone, or with any pair programming partner you choose.</li>
   <li>Suggestion:
     <ul>
       <li>Work on it <em>after</em> completing proj0 and el00&mdash;<em><strong>and do el02 first also</strong></em></li>
       <li>Make it part of your studying for the final exam.</li>
     </ul>
   </li>
   </ul>
 </div>
 
 <hr>
 <span class="smallerFont"><br>
  </span><span class="smallerFont"></span>
  <h2>Goals for this lab</h2>
 <p>This lab is a continuation of the problem solving exercises in el02, and uses the exact same test harness.</p>
 <p>This lab contains three more problems dealing with arrays.</p>
 <p>The six problems are:</p>
 <ol>
   <li>Adding up all the numbers in an array</li>
   <li>Copying only the odd numbers in one array into another array</li>
   <li>Multiplying all the numbers in one array by all the numbers in another and storing the result in a third array.</li>
 </ol>
 <p>As before, the isOdd problem is offered as a warm up to remind you how the test harness works.</p>
 <h2>Prior Skills/Knowledge Needed</h2>
 <p>Before completing this lab, you should be familiar with everything from el02.</p>
 <h2>Step by Step Instructions</h2>
 <h2>&nbsp;</h2>
 <h3>Step 1: Log on to CSIL, create  ~/cs16/el03 and copy this labs files:</h3>
 <p>&nbsp;</p>
 <p>The files for this  lab can be found here:</p>
 <ul>
   <li><a href="http://www.cs.ucsb.edu/~pconrad/cs16/10W/extraLabs/el03/files">http://www.cs.ucsb.edu/~pconrad/cs16/10W/extraLabs/el03/files<br>
   </a></li>
  </ul>
 <p>And here:</p>
 <p><code> ~pconrad/public_html/cs16/10W/extraLabs/el03/files/* </code></p>
 <p>&nbsp;</p>
 <h3>Step 2: Familiarize yourself with the test harness files</h3>
 <p>This week's lab is about problem solving. </p>
 <p>To allow you to focus on the problem as much as possible, we've provided a<em><strong> test harness</strong></em> for you&mdash;</p>
 <div class="sideNoteDiv"> <p>As a remidner, a <em><strong>test harness</strong></em> is a software system that allows you to determine whether a piece of code you are developing has been written correctly or not.</p>
   <p>The test harness for el03 works pretty much the same as the one provided in el02.</p>
 </div>
 <p>Start by cd'ing into the directory ~/cs16/el03, and typing the command ls to list all of your files, as shown:  </p>
 <pre>
-bash-3.2$ <strong>ls</strong>
copyOdds.c  multiplyPairwise.c  tdd.h               testMultiplyPairwiseMain.c
isOdd.c     sumArray.c          testCopyOddsMain.c  testSumArrayMain.c
Makefile    tdd.c               testIsOddMain.c
-bash-3.2$
</pre>
 </p>
 <p>Since you should be familiar with the basic outline from el02. As a reminder, there are four groups of files, as shown in the table below:</p>
 <table border="2" cellspacing="1" cellpadding="1"class="functionGroups">
   <tr>
     <td ><p><strong>Group 1:</strong> <strong>stubs for functions</strong><br>
         <br>
       Each of these files contains </p>
       <ul>
         <li>a function definition in stub form</li>
         <li>a function that runs tests on the function just defined.<br>
            <br>
         </li>
        </ul>
        
        <p>&nbsp;</p></td>
     <td><p><code><a href="files/isOdd.c">isOdd.c<br>
     </a></code><code><a href="files/sumArray.c">sumArray.c</a><a href="files/isOdd.c"><br>
         </a></code><code><a href="files/multiplyPairwise.c">multiplyPairwise.c</a><br>
<a href="files/copyOdds.c">copyOdds.c</a><br>
         </code></p>      </td>
   </tr>
   <tr>
     <td ><p><strong>Group 2:</strong> main programs to run tests<br>
          <br>
       For each of the files in Group 1, there is a corresponding file in Group 2 containing the main program that tests that function. </p>      </td>

     <td><p><code><a href="files/testIsOddMain.c">testIsOddMain.c</a><br>
          <a href="files/testSumArrayMain.c">testSumArrayMain.c</a></code><code><a href="files/testMultiplyPairwiseMain.c">testMultiplyPairwiseMain.c</a><br>
          <a href="files/testSumArrayMain.c"></a><a href="files/testCopyOddsMain.c">testCopyOddsMain.c</a><br>
          <a href="files/testIndexOfMaxMain.c"></a></code></p>       </td>
   </tr>
   <tr>
     <td ><p><strong>Group 3:</strong> Functions for Test-Driven Development</p>
      <p>tdd.h contains function prototypes for:</p>
      <pre class="indentedPre">
int assertTrue(char * label, int  assertion);
int checkExpectInt(char * label, int check, int expect);
int checkExpectDouble(char * label, double check, double expect, <br>                double tolerance);
int checkExpectIntArray(char * label, int * check, int * expect, int n); 
void tddSummary(int failures);

</pre>      
<p>tdd.c contains the function definitions for these. 
<p>&nbsp;</p></td>
     <td><code><a href="files/tdd.h">tdd.h</a><br>
         <a href="files/tdd.c">tdd.c</a></code></td>
   </tr>
   <tr>
     <td ><p><strong>Group 4: The Makefile</strong></p>
      <p>This group consists of a single file called <code>Makefile</code>&mdash;the information in the Makefile makes reusing functions much easier. <br>
        <br>
      The Makefile also contains rules that allow several special commands to be type. Try each of these at the shell prompt:</p>
      
  <table border="2" cellspacing="1" cellpadding="1" class="commandSummary">
  <tr>
    <td style="width: 8em;"><code>make</code></td>
    <td>Compile all of the programs.</td>
  </tr>
  <tr>
    <td style="width: 8em;"><code>make all</code></td>
    <td><p>Compile all of the programs.</p>
      <p>Because this is the first rule in the file, it is also the default rule&mdash;the one that is run when you just type make</p></td>
  </tr>
  <tr>
    <td><code>make clean</code></td>
    <td>Delete all of the executable files&mdash;typing this before make all allows you to recompile everything from scratch.</td>
  </tr>
  <tr>
    <td><code>make test</code></td>
    <td>Run each of the test programs.<br>
      If the programs aren't compiled yet, this rule will do a make all first.</td>
  </tr>
</table>
<p>You aren't responsible for learning the syntax of Makefiles in CS16&mdash;that's a topic for CS32. You only need to know how to use Makefiles in CS16.</p></td>
     <td><a href="files/Makefile"><code>Makefile</code></a></td>
   </tr>
 </table>
 <h4><br>
 </h4>
 <h3>Step 2: Practicing working with the test harness on the isOdd function</h3>
 <p>Before we move on to the problem solving, here's a quick review of how the test harness works.</p>
 <p>(You may be tempted to skip this if you already understand&mdash;but you'll need the isOdd function for the copyOdds problem later in this lab, so you might as well do it anyway&mdash;it will only take 2 minutes if you remember how this goes.)<br>
 </p>
 <p>Working from your ~/cs16/el03 directory, type the commands shown below at the Unix prompt&mdash;this will<br>
 </p>
 <ul>
   <li> clean out any old executables (<code>make clean</code>)</li>
   <li>compile the test program for the isOdd() function (<code>make testIsOdd</code>)</li>
   <li>and then run the test program (<code>./testIsOdd</code>)  </li>
 </ul>
 <pre class="indentedPre">
-bash-3.2$<strong> make clea</strong>n
/bin/rm -f testIsOdd testCopyOdds testSumArray testMultiplyPairwise
-bash-3.2$ <strong>make testIsOdd</strong>
cc isOdd.c tdd.c testIsOddMain.c -o testIsOdd
-bash-3.2$ ./testIsOdd
Test 1: isOdd(1) FAILED: got -42 expected 1
Test 2: isOdd(2) FAILED: got -42 expected 0
Test 3: isOdd(33) FAILED: got -42 expected 1
Test 4: isOdd(44) FAILED: got -42 expected 0
Test 5: isOdd(-7) FAILED: got -42 expected 1
Test 6: isOdd(-8) FAILED: got -42 expected 0
6 tests failed
-bash-3.2$ 
</pre>
 </p>
 <p>Now, open up isOdd.c in the editor, and locate the stub for the isOdd() function.</p>
 <p>Change the stub code (the code that returns -42) to code that:</p>
 <ul>
   <li>returns 1 when x is odd</li>
   <li>return 0 when x is not odd (i.e. when x is even)</li>
  </ul>
 <p>Once you've done that, repeat the <code>make testIsOdd</code> and <code>./testIsOdd</code> steps, and the tests should pass:  </p>
 <pre>
-bash-3.2$ <strong>make testIsOdd</strong>
cc isOdd.c tdd.c testIsOddMain.c -o testIsOdd
-bash-3.2$ <strong>./testIsOdd</strong>
Test 1: isOdd(1) passed
Test 2: isOdd(2) passed
Test 3: isOdd(33) passed
Test 4: isOdd(44) passed
Test 5: isOdd(-7) passed
Test 6: isOdd(-8) passed
All tests passed!
-bash-3.2$ 
  </pre>
 <p>Note that is is not necessary to run the <code>make clean</code> step every time:</p>
 <ul>
   <li>Usually,     <code>make testIsOdd</code>    is enough (put any of the test programs in place of testIsOdd).</li>
   <li><code>make clean</code> is generally used only right before make to force one or more programs to be recompiled</li>
   <li>Otherwise, if the program has already been compiled, and none of the none of the files it depends on have been changed, you'll get the message:<code> 'testIsOdd' is up to date. </code>
     <pre>-bash-3.2$ <strong>make testIsOdd</strong>
make: `testIsOdd' is up to date.
-bash-3.2$ 
</pre>
   </li>
   <li>You also can use the make clean rule if you want to delete the executables to save disk space after you are finished running a program. (You can always remake it from the .c files if you need it again.)</li>
 </ul>
 <p>You'll repeat this process for each of the remaining problems in this assignment:</p>
 <ol>
   <li>make the test program and run it, to see that all the tests fail</li>
   <li>edit the function to replace it with code that you think will solve the problem</li>
   <li>make the test program again, and hopefully the tests pass&mdash;if not, repeat  2 and 3 as needed.</li>
  </ol>
 <h3>Step 3: Finding the sum of an array</h3>
 <p>Next, at the shell prompt, use the commands:</p>
 <p class="indented">
  <strong><code>make testSumArray</code></strong> to compile the test program<br>
  <strong><code>./testSumArray</code></strong> to run the tests for the functions in <a href="files/sumArray.c"><code>sumArray.c</code></a></p>
 <p>Make sure you understand the test cases:</p>
 <ul>
   <li>You can find them inside the file <a href="files/sumArray.c"><code>sumArray.c</code></a><a href="files/maxValue.c"></a> in the <code>testSumArray()</code> function.</li>
 </ul>
 <p>After seeing the tests fail, open up <a href="files/sumArray.c"><code>sumArray.c</code></a>in the editor (emacs or vi) and change the stubs to functions that return the correct values.</p>
 <p>Some hints:</p>
 <ul>
   <li>Use a variable called sum to store the sum of the array&mdash;remember to initialize it to zero.</li>
   <li>Use a for loop that steps through every value in the array</li>
   <li> Inside the loop, add each value into the sum. The += operator may be useful here.</li>
   <li>Return the value of sum, but only after you've added in every value in the array.</li>
  </ul>
  <p>When all the tests pass, move on to the the next problem&mdash;or for an extra challenge consider the following variations on the sumArray problem:</p>
  <div class="extraChallengeDiv">
 <p><strong>For an extra challenge</strong>&mdash;consider the following variations on the sumArray problem:</p>
 <ul>
   <li>How would you find the sum of only the values in the array that are positive?</li>
   <li>How would you find the sum of only the even values in the array?</li>
   <li>How would you find the sum of only the values who indexes are even (i.e. a[0] + a[2] + a[4] + ...)</li>
   <li>Can you think how to solve the basic sumArray problem&mdash;and each of the variations listed above&mdash;using recursion instead of a for loop?</li>
  </ul>
  </div>
 <h3>&nbsp;</h3>
 <h3><strong>Step 4: Multiplying two arrays pairwise</strong></h3>
 <p>This problem involves working with three arrays:</p>
 <ul>
   <li>two source arrays, each containing n integers</li>
   <li>a destination array&mdash;we are going to overwrite the contents of that array with the pairwise product of the two source arrays&mdash;that is result[i] will be set to a[i] times b[i] for every value of i</li>
  </ul>
 <p>A precondition is that the destination array must have capacity no smaller than n.</p>
 <p>As an example, if a and b are the arrays:</p>
  <pre class="indented">
int a[] = {1,2,3,4};
int b[] = {2,4,6,8};<br>int result[4];
</pre>
 <p>Then if we called <code>multPairwise(a,b,result,4)</code>; we would expect that afterwards, the first four elements of result are set equal to  <code>{2,8,18,32}</code>.</p>
 <p>As another example, if we multiply the array </p>
 <pre class="indented">
int a[] = { 1,  2, 3, 4};
int c[] = {-1, 10, 5, 0};
int result[4];</pre>
 <p>Then after calling <code>multPairwise(a,b,result,4)</code>; we would expect result to contain <code>{-1,-20,15,0}</code>.</p>
 <p>This one is fairly straightforward&mdash;you can use a for loop to go through and set each element of the result array to the correct value.</p>
 <p>When all the tests pass, move on to the next problem, or consider first the following challenge.</p>
<div class="extraChallengeDiv"><p>Challenge problems:</p>
  <ul>
    <li>How would you set each element result[i] to be the larger of a[i] or b[i]?</li>
    <li>Suppose there was only a single source array a[i], but you wanted each element of result[i] to be the sum of all the elements from a[0] up to and including a[i], that is:
      <ul>
        <li>result[0] = a[0]</li>
        <li>result[1] = a[0] + a[1]</li>
        <li>result[2] = a[0] + a[1] + a[2]</li>
        <li>...</li>
        <li>result[n-1] = a[0] + a[1] + a[2] + ... a[n-2] + a[n-1]</li>
      </ul>
    </li>
    <li>How would you solve the basic multPairwise problem&mdash;and all the other challenge problems above&mdash;using recursion instead of a for loop?</li>
  </ul>
  </div>
 <p>&nbsp;</p>
 <h3>Step 5: copying all the odd numbers into another array</h3>
 <p>This problem involves working with two arrays:</p>
 <ul>
   <li>a source array, containing n integers</li>
   <li>a destination array&mdash;we are going to overwrite the contents of that array with only the odd integers from the source array.</li>
  </ul>
 <p>A precondition is that the destination array must have capacity no smaller than n.</p>
 <p>The function will return an int value, which is the number of integers that were placed in the destination array.</p>
 <p>Here's the function prototype for copyOdds:</p>
 <pre class="indentedPre">int copyOdds(int *src, int *dest, int n);</pre>
 <p>Here, it may be helpful to review the concepts of the capacity of an array, and the occupancy of an array.</p>
 <p>Let's consider the test cases in <a href="files/copyOdds.c"><code>copyOdds.c</code></a> as an example&mdash;starting with the first one:  </p>
 <pre class="indentedPre">
   // TEST CASE 1: source and destination array are of equal sizes               

  int a[] = {1,2,3};
  int aOdds[3] = {-42,-42,-42}; // fill with dummy values                       
  int aOddsExpected[3] = {1,3}; // occupancy is 2                               
  int aNumOdds;

  aNumOdds = copyOdds(a,3,aOdds,3);
  failures += checkExpectInt("copyOdds(a,3,aOdds,3)--checking return--",
                             aNumOdds, 2);
  failures += checkExpectIntArray("copyOdds(a,3,aOdds,3)--checking array---",
                                  aOdds, aOddsExpected, 2);
 </pre>
 <p>Here, the source array is a, and it has both occupancy and capacity of 3:
 
 <table border="2" cellspacing="1" cellpadding="1">
    <tr>
      <td>a[0]</td>
      <td>a[1]</td>
      <td>a[2]</td>
    </tr>
    <tr>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
  </table>
  <p>The destination array is aOdds, and it initially has capacity of 3, but when we first declare it, it has occupancy&nbsp;of&nbsp;0&mdash;because we haven't stored any values in it yet. The values that it contains are unknown, which we can represent with the ? in the diagram below:</p>
  <table border="2" cellspacing="1" cellpadding="1">
    <tr>
      <td>aOdds[0]</td>
      <td>aOdds[1]</td>
      <td>aOdds[2]</td>
    </tr>
    <tr>
      <td>?</td>
      <td>?</td>
      <td>?</td>
    </tr>
  </table>
  <p>After we make the call to copyOdds(a,3,aOdds,3), what we want is for the aOdds to contain only the odd numbers from the original array a. That is, its occupancy will be 2&mdash;which the number we expect to be assigned into aNumOdds (the number of odds that are in the a array.)</p>
  <table border="2" cellpadding="1" cellspacing="1">
    <tr>
      <td>aOdds[0]</td>
      <td>aOdds[1]</td>
      <td>aOdds[2]</td>
    </tr>
    <tr>
      <td>1</td>
      <td>3</td>
      <td>?</td>
    </tr>
  </table>
  <p>The value returned by copyOdds is the new occupancy of aOdds&mdash;a number that we must return, because without it, we have no way (in C) to determine the actual occupancy of aOdds. We can use checkExpectIntArray() to verify that the first 2 elements of aOdds match the values in aOddsExpected:</p>
  <table border="2" cellpadding="1" cellspacing="1">
    <tr>
      <td>aOdds[0]</td>
      <td>aOdds[1]</td>
      <td>aOdds[2]</td>
    </tr>
    <tr>
      <td>1</td>
      <td>3</td>
      <td>?</td>
    </tr>
    
    <tr>
      <td><span class="style1">aOddsExpected[0]</span></td>
      <td><span class="style1">aOddsExpected[1]</span></td>
      <td rowspan="2" class="noBorder">&nbsp;</td>
    </tr>
    <tr>
      <td>1</td>
      <td>3</td>
    </tr>
  </table>
  <p>The rest of the test cases proceed in a similar fashion.</p>
  <p>When writing the function, consider these hints:</p>
  <ul>
    <li>You'll need to keep track of how many odd numbers you've encountered so far&mdash;in the end, you have to return that as the result of the function.</li>
    <li>When placing values into the consecutive elements of an array called a, you place the first value you find into a[0], the second into a[1], etc.
      This leads to an important thing to keep in mind&mdash;and a frequent cause of errors in functions such as copyOdds:
      <ul>
        <li>Suppose you have  variable called count that is keeping track of how many element you've put into an array.</li>
        <li>If count is 2, that means you have already used a[0] and a[1], and the next value goes into a[2]. After you store that value into a[2], THEN you want count to become 3.</li>
        <li>Think about that when deciding which comes first: storing a result into the destination array, or incrementing the count variable.</li>
      </ul>
    </li>
  </ul>
  <p>When you are finished, and the tests pass, you are finished&mdash;since this is an extra lab, there is nothing to turn in.</p>
  <p>However, you may like to also consider these extra challenge problems:</p>
  <div class="extraChallengeDiv">
    <p><strong>For an extra challenge</strong>&mdash;consider the following variations on the copyOdds problem. For each one, also consider a good name for the function, what its parameters should be, and what the function should return.</p>
    <ul>
      <li>How would you copy only the even elements or the positive ones, or the negative ones?</li>
      <li>How would you copy only the values with odd indexes, or even indexes?</li>
      <li>Here's an easy one: how would you copy only the 1st half of the array&mdash;e.g. for an array with 8 elements, copy elements src[0],src[1], src[2],src[3] into dest[0], dest[1], dest[2] and dest[3]?
        <ul>
          <li>If there are an odd number of elements, round up so that you include the middle element---e.g. for n=5, copy src[1],src[2] into dest[0], dest[1], dest[2].</li>
        </ul>
      </li>
      <li>Slightly harder, how would you copy only the 2nd half of the array&mdash;e.g. for an array with 8 elements, copy elements src[4],src[5], src[6],src[7] into dest[0], dest[1], dest[2] and dest[3]?
        <ul>
          <li>If there are an odd number of elements, round up so that you include the middle element---e.g. for n=5, copy src[2],src[3],src[4] into dest[0], dest[1], dest[2].</li>
        </ul>
      </li>
      <li>How would you copy the array backwards---e.g. dest[0] get src[n-1], dest[1] gets src[n-2], ... dest[n-1] gets src[0] ?</li>
      <li>Can you think how to solve the basic copyOdds problem&mdash;and each of the variations listed above&mdash;using recursion instead of a for loop?</li>
    </ul>
  </div>
  <p>&nbsp;</p>
  <hr>
 <p>Copyright 2010, Phillip T. Conrad, CS Dept, UC Santa Barbara. Permission to copy for non-commercial, non-profit, educational purposes granted, provided appropriate credit is given;  all other rights reserved. </p>
</div>
<!-- id = "container" -->
</body>
</html>
